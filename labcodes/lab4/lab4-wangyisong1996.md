# Lab 4 实验报告

## 练习0：填写已有实验

已填写 Lab 1/2/3 的代码，能正常编译。

## 练习1：分配并初始化一个进程控制块

简要实现过程：
将 `proc` 中的所有变量都初始化为 0 ，除了 `state` 设为 `PROC_UNINIT`，`pid` 设为 -1 （表示未被初始化），`cr3` 设为 `boot_cr3` （即，使用内核的页目录表的基址）。

### 回答问题：请说明`proc_struct`中`struct context context`和`struct trapframe *tf`成员变量含义和在本实验中的作用是啥？（提示通过看代码和编程调试可以判断出来）

`context`即上下文，保存了该进程当前执行状态的各寄存器的信息，`tf`为该进程切换出来时中断的trapframe。
在本实验中，`context`是用来实现上下文切换的，而trapframe是用来使中断处理结束时的iret能返回到正确的位置上去的。

## 练习2：为新创建的内核线程分配资源

简要实现过程：
- 先调用`alloc_proc`，分配一个`proc_struct`结构（如果分配失败转出错处理）
- 设置新进程的parent变量为当前进程
- 用`setup_kstack`给新进程分配内核栈（同样要进行错误处理）
- 调用`copy_mm`复制进程的内存管理信息到新进程
- 调用`copy_thread`将进程的上下文复制到新进程
- 给新进程分配一个pid，并将新进程插入hash链表和进程链表
- **注意**，在上一步中，需要关闭中断，因为这些操作不能被打断
- 调用`wakeup_proc`唤醒新进程，并返回新进程的pid

### 回答问题：请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。

能。因为每个被fork出来的线程，都有不同的内核栈。我们可以用内核栈的起始地址来唯一确定线程。
（注：原理课中提到，ucore这么实现会有很多缺陷，比如当一个线程的内核栈溢出时，会影响其他线程的内核栈并最终导致内核崩溃）

## 练习3：阅读代码，理解 `proc_run` 函数和它调用的函数如何完成进程切换的。

在`proc_run`中，首先关中断，然后将栈和页表切换为新进程的，再切换上下文，最后恢复中断。其中切换上下文是用`switch_to`这个用汇编写的函数来实现的。

### 回答问题：在本实验的执行过程中，创建且运行了几个内核线程？

2个。第一个是`idleproc`，第二个是用来输出Hello world的`init_main`。

### 回答问题：语句`local_intr_save(intr_flag);....local_intr_restore(intr_flag);`在这里有何作用?请说明理由

关中断和开中断。有些操作要求不能被打断，于是必须这么做。


## 与参考答案的区别

只有一处：在`alloc_proc`时，参考答案将`proc->name`全部memset了，而我只将其首个字节设为0，因为这个变量表示的是字符串，这样已经能达到初始化的目的。
在实验的过程中，我没有注意到在进行一些操作时要关中断，后来在看了参考答案后才意识到。感觉这一类问题一定要且只能想清楚，不然很少会因此出现bug，而且出现了也几乎不可能重现。


