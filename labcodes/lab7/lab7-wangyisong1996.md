# Lab 7 实验报告

## 练习0：填写已有实验

我已填写 Lab 1 ~ Lab 6 的代码，并按照要求将其改进（在 trap.c 中时钟中断时加入对 run_timer_list() 的调用 ），能通过编译（和 make grade 的所有测试用例）。

## 练习1: 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题（不需要编码）

### 请给出内核级信号量的设计描述，并说其大致执行流程。

内核级信号量在 sem.h 和 sem.c 中定义和实现，其内容为一个整数 value ，和一个 wait_queue 。

在说明内核级信号量的设计之前，先说明 wait_queue 的设计：
- wait_queue 在 wait.h 和 wait.c 中被定义和实现
- wait_queue 的每一项保存了进程的 proc_struct 和进程等待的原因
- wait_queue 对外提供的接口主要是，将一个进程插入到队列或从中删除，唤醒队列中的某个进程或全部进程

回到信号量的实现。在 P 操作（down 函数）中，首先关中断，然后分两种情况讨论：
- 如果信号量的值大于 0 ，那么将这个值减一即可
- 如果信号量的值等于 0 ，则将当前进程插入该信号量的 wait_queue 中，然后调用 schedule 放弃当前进程的 CPU 使用权。等到该进程再次运行（即从 wait_queue 中被唤醒）时，再从 P 操作中返回

在 V 操作（up 函数）中，同样首先关中断，然后也是分两种情况讨论：
- 如果信号量的 wait_queue 为空，那么将信号量的值加一
- 如果信号量的 wait_queue 不为空，那么从队列中取出一个进程，将其唤醒（即，被取出的进程获得了该信号量）

最后，在 P 操作和 V 操作结束的之前，都要开中断。

### 请给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同。

给用户态进程和线程提供信号量机制一般来说有两种设计方案。

第一种是基于内核态信号量的。我们可以通过系统调用，将内核态信号量封装起来，给用户态进程使用。
这种方法的好处是跟内核态信号量的行为完全一致，并且可以跨进程使用。但是由于要通过系统调用，坏处是开销稍大。

第二种方案是基于软件的同步方法的。我们可以使用一些基于软件（用户态程序）的方法（如 Peterson 算法）来实现互斥锁，于是就可以在用户态直接实现信号量。
这种方法的好处是不需要额外的系统调用，并且用户可以自己设计实现的算法。缺点是只能在同一个用户态进程的不同线程之间使用（因为要使用共享内存），而且由于使用忙等待（busy wait)，效率低下。

## 练习2: 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题（需要编码）

### 请在实验报告中给出内核级条件变量的设计描述，并说其大致执行流程。

内核级条件变量的定义如下：

```c
typedef struct condvar{
    semaphore_t sem;        // the sem semaphore  is used to down the waiting proc, and the signaling proc should up the waiting proc
    int count;              // the number of waiters on condvar
    monitor_t * owner;      // the owner(monitor) of this condvar
} condvar_t;
```

其中 sem 为一个信号量，用来保存在这个条件变量上等待的进程。count 表示在 sem 上等待的进程的个数。

在条件变量所属的管程中，也有一个信号量 next，用来保存在 cond_signal 过程中因唤醒其他进程而等待的进程（被唤醒的进程**立即执行**，这也叫 Hoare 管程），以及一个整数 next_count 表示这些进程的个数。

条件变量的 cond_wait 操作的大致执行流程如下：
- count 加一
- 此时当前进程进入等待状态，如果管程中 next_count 大于 0 ，则唤醒一个管程中将要继续执行的进程，否则没有进程执行，释放管程的 mutex
- 在条件变量的 sem 上等待（该操作阻塞）
- 等待结束，count 减一

条件变量的 cond_signal 操作的大致执行流程如下：
- 如果 count 等于 0，则什么都不用做，直接返回
- 此时需要将等待该条件变量的一个进程取出（并执行），并将当前进程放入管程的 next 队列中，具体来说，先给管程的 next_count 加一
- 唤醒一个条件变量的 sem 中等待的进程
- 在管程的 next 信号量上等待（阻塞）
- 等待结束，将管程的 next_count 减一，此时可以继续执行


### 请在实验报告中给出给用户态进程/线程提供条件变量机制的设计方案，并比较说明给内核级提供条件变量机制的异同。

可以在内核态实现管程和条件变量，然后封装成系统调用提供给用户态。
这样的功能完全一样，但是每次调用都要进行进程切换，效率会变低。

### 请在实验报告中回答：能否不用基于信号量机制来完成条件变量？如果不能，请给出理由，如果能，请给出设计说明和具体实现。

能。上文所述的内核级条件变量就是用信号量机制实现的。（即，是信号量的一个简单封装）


## 与参考答案的区别

仔细对照参考答案之后，发现我的实现在语义上与参考答案完全一样。

## 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）

在本实验中，信号量、条件变量和管程为重要的知识点。这些知识点在原理课中都有直接的对应。

## 列出你认为OS原理中很重要，但在实验中没有对应上的知识点

在原理课中，各种类型的同步互斥都被介绍，而在本实验中只要求理解在 ucore 中实现的同步互斥机制。
具体来说，信号量等同步互斥机制可以实现在内核态，也可以实现在用户态，而在本实验中只讨论了内核态的实现。
管程有 Hoare 管程和 Hansen 管程这两种，其中前者是在条件变量的 signal 之后让被唤醒的进程立即继续执行，而后者不是。在本实验中，只讨论了 Hoare 管程的实现，而实际应用更广泛的 Hansen 管程并没有被提及。

